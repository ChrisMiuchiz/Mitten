import struct
import io
import zlib
from .Packet import Packet
from CubeTypes.LongVector3 import LongVector3
from CubeTypes.FloatVector3 import FloatVector3
from CubeTypes.Appearance import Appearance
from CubeTypes.IntVector3 import IntVector3
from CubeTypes.Item import Item
from CubeTypes.Equipment import Equipment
from CubeTypes.StatMultipliers import StatMultipliers

class DeltaField():
    def __init__(self, field_name, type_or_packstring, multi_field_packstring=False):
        self.field_name = field_name
        self.type_or_packstring = type_or_packstring
        self.multi_field_packstring = multi_field_packstring

        self.isTypeValue = hasattr(self.type_or_packstring, 'Import')
        if self.isTypeValue:
            self.data_size = self.type_or_packstring.size
        else:
            self.data_size = struct.calcsize(self.type_or_packstring)

    def Read(self, rdr):
        # Import / unpack
        if self.isTypeValue:
            val = self.type_or_packstring.Import(rdr)
        else:
            val = struct.unpack(self.type_or_packstring, rdr.read(self.data_size))
            if self.multi_field_packstring == False:
                val = val[0]

        return val

    def Write(self, wtr, read_val):
        if self.isTypeValue:
            wtr.write(read_val.Export())
        else:
            if self.multi_field_packstring:
                wtr.write(struct.pack(self.type_or_packstring, *read_val))
            else:
                wtr.write(struct.pack(self.type_or_packstring, read_val))
            

# These share the exact field names as the Creature type so that the fields can
# easily be applied onto a Creature with `setattr` in the future, or generated by
# diffing two Creatures.
DELTA_TYPES = [
    DeltaField("position", LongVector3),
    DeltaField("orientation", FloatVector3),
    DeltaField("velocity", FloatVector3),
    DeltaField("acceleration", FloatVector3),
    DeltaField("retreat", FloatVector3),
    DeltaField("headRotation", '<f'),
    DeltaField("physicsFlags", '<I'),
    DeltaField("hostility", '<B'),
    DeltaField("creatureType", '<I'),
    DeltaField("mode", '<B'),
    DeltaField("modeTimer", '<i'),
    DeltaField("combo", '<i'),
    DeltaField("lastHitTime", '<i'),
    DeltaField("appearance", Appearance),
    DeltaField("creatureFlags", '<H'),
    DeltaField("rollTime", '<i'),
    DeltaField("stunTime", '<i'),
    DeltaField("slowedTime", '<i'),
    DeltaField("iceEffectTime", '<i'),
    DeltaField("windEffectTime", '<i'),
    DeltaField("showPatchTime", '<f'),
    DeltaField("classType", '<B'),
    DeltaField("specialization", '<B'),
    DeltaField("chargedMP", '<f'),
    DeltaField("unkIntVec1", IntVector3),
    DeltaField("unkIntVec2", IntVector3),
    DeltaField("rayHit", FloatVector3),
    DeltaField("HP", '<f'),
    DeltaField("MP", '<f'),
    DeltaField("blockPower", '<f'),
    DeltaField("statMultipliers", StatMultipliers),
    DeltaField("unkByte1", '<B'),
    DeltaField("unkByte2", '<B'),
    DeltaField("level", '<i'),
    DeltaField("XP", '<i'),
    DeltaField("parentOwner", '<q'),
    DeltaField("unkLong1", '<q'),
    DeltaField("powerBase", '<B'),
    DeltaField("unkInt1", '<i'),
    DeltaField("superWeird", IntVector3), # Spawn chunk, need to rename
    DeltaField("spawnPosition", LongVector3),
    DeltaField("unkIntVec3", IntVector3),
    DeltaField("unkByte3", '<B'),
    DeltaField("consumable", Item),
    DeltaField("equipment", Equipment),
    DeltaField("name", '16s'),
    DeltaField("skills", '<iiiiiiiiiii', multi_field_packstring=True),
    DeltaField("manaCubes", '<i')
]
assert(len(DELTA_TYPES) == 48)

class EntityUpdatePacket(Packet):
    pID = 0x0
    def __init__(self, entity_id, fields):
        self.entity_id = entity_id
        self.fields = fields

    @staticmethod
    def Recv(connection, fromClient):
        recv = [connection.RecvServer, connection.RecvClient][fromClient]
        
        # Read and decompress the zlib data
        zlibDataSize, = struct.unpack('<I', recv(4))
        zlibData = recv(zlibDataSize)

        # Read decompressed packet.
        rdr = io.BytesIO(zlib.decompress(zlibData))
        entity_id, = struct.unpack('<q', rdr.read(8))
        bitfield, = struct.unpack('<q', rdr.read(8))

        fields = {}
        for i in range(len(DELTA_TYPES)):
            t = DELTA_TYPES[i]
            if (1 << i) & bitfield:
                fields[t.field_name] = t.Read(rdr)

        # Special-case for name field
        if 'name' in fields:
            # c-string, split by first null and decode from bytes.
            fields['name'] = fields['name'].split(b'\x00')[0].decode()

        return EntityUpdatePacket(entity_id, fields)

    def Export(self, toServer):
        packetByteList = []
        packetByteList.append( struct.pack('<I', EntityUpdatePacket.pID) )

        # Export the masked data / creature delta
        bitfield = 0
        field_output = io.BytesIO()

        for i in range(len(DELTA_TYPES)):
            t = DELTA_TYPES[i]
            if t.field_name in self.fields:
                # Set the bit
                bitfield |= (1<<i)

                data = self.fields[t.field_name]
                # Special-case for name field, to write the encoded name without changing self.fields on export.
                if t.field_name == 'name':
                    # Make sure it's encoded into a bytes-like object.
                    data = self.fields['name'].encode()

                # Write the data
                t.Write(field_output, data)

        # Write the data to be compressed
        deltaData = struct.pack('<q', self.entity_id)
        deltaData += struct.pack('<q', bitfield)
        deltaData += field_output.getbuffer()
        zlibData = zlib.compress(deltaData)

        # Write the zlib data
        packetByteList.append( struct.pack('<I', len(zlibData)) )
        packetByteList.append( zlibData )
        return b''.join(packetByteList)

    def Send(self, connection, toServer):
        send = [connection.SendClient, connection.SendServer][toServer]
        return send(self.Export(toServer))
